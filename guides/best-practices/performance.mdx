---
title: "Performance"
description: "Optimize your Pan API integration for best performance"
---

This guide covers performance optimization techniques for integrating with Pan API.

## Request optimization

<CardGroup cols={2}>
  <Card title="Batch operations" icon="layer-group">
    When possible, batch operations to reduce the number of API calls.
  </Card>
  <Card title="Cache responses" icon="database">
    Cache wallet information and other data that doesn't change frequently.
  </Card>
</CardGroup>

## Caching strategies

### Wallet information

Wallet addresses and IDs rarely change. Cache this information:

<CodeGroup>
```javascript JavaScript
const walletCache = new Map();

async function getWalletCached(userId) {
  // Check cache first
  if (walletCache.has(userId)) {
    return walletCache.get(userId);
  }
  
  // Fetch from API
  const wallet = await getWalletByUserId(userId);
  
  // Cache for 1 hour
  walletCache.set(userId, wallet);
  setTimeout(() => walletCache.delete(userId), 60 * 60 * 1000);
  
  return wallet;
}
```
</CodeGroup>

### Balance caching

Balance data changes frequently, so cache with shorter TTL:

<CodeGroup>
```javascript JavaScript
const balanceCache = new Map();

async function getBalancesCached(walletId) {
  const cacheKey = `balance:${walletId}`;
  const cached = balanceCache.get(cacheKey);
  
  // Return cached if less than 10 seconds old
  if (cached && Date.now() - cached.timestamp < 10000) {
    return cached.data;
  }
  
  const balances = await getBalances(walletId);
  
  balanceCache.set(cacheKey, {
    data: balances,
    timestamp: Date.now()
  });
  
  return balances;
}
```
</CodeGroup>

<Warning>
  **Balance freshness**: Don't cache balances for too long - they change with transactions. Use short TTLs (5-10 seconds) or invalidate cache after transactions.
</Warning>

## Rate limiting

Understand and respect rate limits:

<CardGroup cols={3}>
  <Card title="Free plan" icon="gift">
    **100 requests/minute**
    
    Suitable for development and small applications
  </Card>
  <Card title="Pro plan" icon="star">
    **1,000 requests/minute**
    
    For production applications with moderate traffic
  </Card>
  <Card title="Enterprise" icon="crown">
    **Custom limits**
    
    Tailored to your needs
  </Card>
</CardGroup>

### Rate limit monitoring

Monitor rate limit headers:

<CodeGroup>
```javascript JavaScript
function checkRateLimit(response) {
  const remaining = parseInt(response.headers.get('X-RateLimit-Remaining') || '0');
  const limit = parseInt(response.headers.get('X-RateLimit-Limit') || '0');
  const resetTime = parseInt(response.headers.get('X-RateLimit-Reset') || '0');
  
  if (remaining < 10) {
    console.warn(`Rate limit warning: ${remaining}/${limit} requests remaining`);
    
    // Slow down requests
    return {
      shouldSlowDown: true,
      resetTime: new Date(resetTime * 1000)
    };
  }
  
  return { shouldSlowDown: false };
}
```
</CodeGroup>

## Async operations

Intent execution is asynchronous. Design your application accordingly:

<CodeGroup>
```javascript JavaScript
// ✅ Good: Don't block on intent creation
async function createIntentAsync(walletId, params) {
  const intent = await createIntent({
    walletId,
    ...params
  });
  
  // Return immediately, poll status separately
  return intent;
}

// Start polling in background
async function handleIntentCreation(intent) {
  // Store intent ID in database
  await saveIntentToDatabase(intent.id, intent.status);
  
  // Poll status in background
  pollIntentStatus(intent.id).then(updatedIntent => {
    updateIntentInDatabase(updatedIntent);
    notifyUser(updatedIntent);
  });
}
```
</CodeGroup>

## Polling optimization

Optimize intent status polling:

<Tip>
  **Polling intervals**: Use appropriate intervals based on intent status:
  - `pending`: 2 seconds
  - `planning`: 5 seconds
  - `executing`: 5-10 seconds
  - `completed`/`failed`: Stop polling immediately
</Tip>

<CodeGroup>
```javascript JavaScript
function getPollInterval(status) {
  const intervals = {
    pending: 2000,   // 2 seconds
    planning: 5000,  // 5 seconds
    executing: 5000  // 5 seconds
  };
  
  return intervals[status] || 5000;
}

async function pollIntentStatus(intentId) {
  let lastStatus = null;
  
  while (true) {
    const intent = await getIntent(intentId);
    
    // Stop if completed or failed
    if (intent.status === 'completed' || intent.status === 'failed') {
      return intent;
    }
    
    // Use dynamic interval based on status
    const interval = getPollInterval(intent.status);
    
    // Increase interval if status hasn't changed
    const waitTime = intent.status === lastStatus 
      ? interval * 1.5  // Slow down if stuck
      : interval;
    
    await new Promise(resolve => setTimeout(resolve, waitTime));
    lastStatus = intent.status;
  }
}
```
</CodeGroup>

## Parallel requests

When possible, make parallel requests:

<CodeGroup>
```javascript JavaScript
// ✅ Good: Parallel requests
async function getMultipleWallets(userIds) {
  const wallets = await Promise.all(
    userIds.map(userId => getWalletByUserId(userId))
  );
  
  return wallets;
}

// ✅ Good: Parallel balance checks
async function getBalancesForWallets(walletIds) {
  const balances = await Promise.allSettled(
    walletIds.map(walletId => getBalances(walletId))
  );
  
  return balances.map((result, index) => ({
    walletId: walletIds[index],
    balance: result.status === 'fulfilled' ? result.value : null,
    error: result.status === 'rejected' ? result.reason : null
  }));
}
```
</CodeGroup>

<Warning>
  **Rate limits**: Parallel requests consume rate limits faster. Be mindful of your plan's limits.
</Warning>

## Connection pooling

Use HTTP connection pooling when possible:

<CodeGroup>
```javascript JavaScript
// Using a client library with connection pooling (e.g., axios)
import axios from 'axios';

const apiClient = axios.create({
  baseURL: 'https://api.pan.dev/v1',
  timeout: 30000,
  headers: {
    'Authorization': `Bearer ${process.env.PAN_API_KEY}`
  },
  // Connection pooling configuration
  httpAgent: new http.Agent({
    keepAlive: true,
    maxSockets: 10
  })
});
```
</CodeGroup>

## Timeout configuration

Set appropriate timeouts:

<AccordionGroup>
  <Accordion title="Short operations">
    Wallet creation and retrieval should complete quickly (5-10 seconds):
    
    ```javascript
    const timeout = 10000; // 10 seconds
    ```
  </Accordion>
  
  <Accordion title="Long operations">
    Balance queries and intent creation may take longer (30 seconds):
    
    ```javascript
    const timeout = 30000; // 30 seconds
    ```
  </Accordion>
</AccordionGroup>

## Best practices summary

<Tip>
  ✅ Cache wallet information (1 hour TTL)
  ✅ Cache balances briefly (5-10 seconds TTL)
  ✅ Use appropriate polling intervals
  ✅ Make parallel requests when safe
  ✅ Monitor rate limit headers
  ✅ Set appropriate timeouts
  ✅ Use connection pooling
  ✅ Stop polling when complete
</Tip>

<Warning>
  ❌ Don't cache balances too long
  ❌ Don't poll too frequently
  ❌ Don't ignore rate limits
  ❌ Don't block on async operations
</Warning>

## Related guides

<CardGroup cols={2}>
  <Card
    title="Error handling"
    icon="exclamation-triangle"
    href="/guides/best-practices/error-handling"
  >
    Handle errors efficiently
  </Card>
  <Card
    title="Integration"
    icon="puzzle-piece"
    href="/guides/best-practices/integration"
  >
    Integration patterns and practices
  </Card>
</CardGroup>

