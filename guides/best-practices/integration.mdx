---
title: "Integration"
description: "Integration patterns and best practices for Pan API"
---

This guide covers integration patterns, architecture considerations, and best practices for building applications with Pan API.

## Architecture patterns

### Server-side proxy

<Card
  title="Recommended: Server-side proxy"
  icon="server"
>
  Keep API keys on the server. Build a proxy API that your client applications call, which then calls Pan API.
</Card>

<CodeGroup>
```javascript JavaScript
// Server-side proxy endpoint
app.post('/api/wallets', async (req, res) => {
  try {
    // Validate user authentication
    const user = await authenticateUser(req);
    
    // Call Pan API with server-side API key
    const wallet = await panClient.createWallet({
      userId: user.id,
      metadata: {
        email: user.email
      }
    });
    
    res.json(wallet);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```
</CodeGroup>

**Benefits**:
- ✅ API keys never exposed to clients
- ✅ Can add authentication/authorization
- ✅ Can add caching and rate limiting
- ✅ Can transform responses for your needs

### Direct client integration

<Warning>
  **Not recommended**: Direct client integration requires exposing API keys in client code, which is a security risk.
</Warning>

If you must use direct integration, implement additional security measures.

## State management

### Wallet state

Store wallet information in your database:

<CodeGroup>
```sql
CREATE TABLE wallets (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL,
  pan_wallet_id VARCHAR(255) NOT NULL,
  pan_address VARCHAR(255) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  UNIQUE(user_id),
  UNIQUE(pan_wallet_id)
);
```
</CodeGroup>

### Intent state

Track intent status in your database:

<CodeGroup>
```sql
CREATE TABLE intents (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL,
  pan_intent_id VARCHAR(255) NOT NULL,
  wallet_id UUID NOT NULL,
  status VARCHAR(50) NOT NULL,
  action VARCHAR(50) NOT NULL,
  amount DECIMAL NOT NULL,
  asset VARCHAR(10) NOT NULL,
  chain VARCHAR(50) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  completed_at TIMESTAMP,
  FOREIGN KEY (wallet_id) REFERENCES wallets(id)
);
```
</CodeGroup>

## Background jobs

Use background jobs for long-running operations:

<CodeGroup>
```javascript JavaScript
// Queue job to poll intent status
async function queueIntentPolling(intentId, userId) {
  await jobQueue.add('poll-intent-status', {
    intentId,
    userId
  }, {
    attempts: 120,      // Poll up to 120 times
    backoff: {
      type: 'exponential',
      delay: 5000       // Start with 5 second intervals
    }
  });
}

// Background job processor
jobQueue.process('poll-intent-status', async (job) => {
  const { intentId, userId } = job.data;
  
  const intent = await panClient.getIntent(intentId);
  
  // Update database
  await updateIntentInDatabase(intent);
  
  // Notify user if complete
  if (intent.status === 'completed' || intent.status === 'failed') {
    await notifyUser(userId, intent);
    return;
  }
  
  // Continue polling
  throw new Error('Intent still processing');
});
```
</CodeGroup>

## Webhook preparation

Prepare for webhooks even though they're not available yet:

<CodeGroup>
```javascript JavaScript
// Webhook endpoint (ready for future implementation)
app.post('/webhooks/pan', async (req, res) => {
  // Verify webhook signature
  const signature = req.headers['x-pan-signature'];
  const isValid = verifyWebhookSignature(req.body, signature);
  
  if (!isValid) {
    return res.status(401).send('Invalid signature');
  }
  
  const event = req.body;
  
  switch (event.type) {
    case 'intent.completed':
      await handleIntentCompleted(event.data);
      break;
    case 'intent.failed':
      await handleIntentFailed(event.data);
      break;
  }
  
  res.status(200).send('OK');
});
```
</CodeGroup>

## Error recovery

Implement retry logic with exponential backoff:

<CodeGroup>
```javascript JavaScript
async function createIntentWithRetry(params, maxRetries = 3) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await panClient.createIntent(params);
    } catch (error) {
      // Don't retry client errors
      if (error.status >= 400 && error.status < 500) {
        throw error;
      }
      
      // Retry server errors
      if (attempt < maxRetries - 1) {
        const delay = Math.pow(2, attempt) * 1000;
        await new Promise(resolve => setTimeout(resolve, delay));
      } else {
        throw error;
      }
    }
  }
}
```
</CodeGroup>

## Testing

### Mock Pan API for testing

<CodeGroup>
```javascript JavaScript
// Mock Pan client for tests
class MockPanClient {
  async createWallet(params) {
    return {
      id: 'wallet_mock_123',
      userId: params.userId,
      address: '0x' + '0'.repeat(40),
      chains: ['ethereum-sepolia'],
      createdAt: new Date().toISOString()
    };
  }
  
  async getIntent(intentId) {
    return {
      id: intentId,
      status: 'completed',
      // ... mock data
    };
  }
}

// Use in tests
const panClient = process.env.NODE_ENV === 'test' 
  ? new MockPanClient()
  : new PanClient();
```
</CodeGroup>

## Monitoring and logging

Log important operations:

<CodeGroup>
```javascript JavaScript
async function createWalletWithLogging(userId, metadata) {
  const startTime = Date.now();
  
  try {
    const wallet = await panClient.createWallet({ userId, metadata });
    
    logger.info('Wallet created', {
      walletId: wallet.id,
      userId,
      duration: Date.now() - startTime
    });
    
    return wallet;
  } catch (error) {
    logger.error('Wallet creation failed', {
      userId,
      error: error.message,
      duration: Date.now() - startTime
    });
    
    throw error;
  }
}
```
</CodeGroup>

## Best practices checklist

<Check>
  ✅ Use server-side proxy pattern
  ✅ Store wallet and intent state in database
  ✅ Use background jobs for polling
  ✅ Implement proper error handling
  ✅ Add comprehensive logging
  ✅ Prepare for webhooks
  ✅ Use connection pooling
  ✅ Implement caching
  ✅ Monitor rate limits
  ✅ Test with mocks
</Check>

## Related guides

<CardGroup cols={2}>
  <Card
    title="Security"
    icon="shield"
    href="/guides/best-practices/security"
  >
    Secure integration practices
  </Card>
  <Card
    title="Performance"
    icon="bolt"
    href="/guides/best-practices/performance"
  >
    Optimize your integration
  </Card>
</CardGroup>

