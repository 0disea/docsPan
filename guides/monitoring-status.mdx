---
title: "Monitoring Status"
description: "Best practices for tracking intent execution progress"
---

Since intent execution is asynchronous and can take several minutes, you need to monitor intent status to provide feedback to users. This guide covers best practices for tracking intent execution.

## Polling basics

Poll the intent status endpoint at regular intervals:

<CodeGroup>
```javascript JavaScript
async function pollIntentStatus(intentId) {
  const response = await fetch(
    `https://api.pan.dev/v1/intents/${intentId}`,
    {
      headers: {
        'Authorization': `Bearer ${process.env.PAN_API_KEY}`
      }
    }
  );
  
  return await response.json();
}

// Poll every 5 seconds
setInterval(async () => {
  const intent = await pollIntentStatus('intent_xyz789');
  console.log(`Status: ${intent.status}`);
}, 5000);
```
</CodeGroup>

## Recommended polling interval

<CardGroup cols={3}>
  <Card title="Active operations" icon="bolt">
    **5 seconds**
    
    While intent is `planning` or `executing`, poll every 5 seconds for responsive updates.
  </Card>
  <Card title="Pending state" icon="clock">
    **2 seconds**
    
    When status is `pending`, poll more frequently (every 2 seconds) since this state is brief.
  </Card>
  <Card title="Completed/Failed" icon="stop">
    **Stop polling**
    
    Once status is `completed` or `failed`, stop polling immediately.
  </Card>
</CardGroup>

## Complete polling implementation

Here's a robust polling implementation with proper error handling:

<CodeGroup>
```javascript JavaScript
async function waitForIntentCompletion(intentId, onStatusUpdate) {
  const pollInterval = 5000; // 5 seconds
  const maxWaitTime = 600000; // 10 minutes
  const startTime = Date.now();
  
  while (Date.now() - startTime < maxWaitTime) {
    try {
      const response = await fetch(
        `https://api.pan.dev/v1/intents/${intentId}`,
        {
          headers: {
            'Authorization': `Bearer ${process.env.PAN_API_KEY}`
          }
        }
      );
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const intent = await response.json();
      
      // Call status update callback
      if (onStatusUpdate) {
        onStatusUpdate(intent);
      }
      
      // Check if complete
      if (intent.status === 'completed') {
        return {
          success: true,
          intent: intent,
          metrics: intent.metrics
        };
      }
      
      if (intent.status === 'failed') {
        return {
          success: false,
          intent: intent,
          error: intent.error
        };
      }
      
      // Wait before next poll
      await new Promise(resolve => setTimeout(resolve, pollInterval));
      
    } catch (error) {
      console.error('Error polling intent status:', error);
      
      // On network errors, wait longer before retry
      await new Promise(resolve => setTimeout(resolve, pollInterval * 2));
    }
  }
  
  throw new Error('Intent polling timed out after 10 minutes');
}
```
</CodeGroup>

## Showing progress to users

Provide visual feedback based on intent status:

<CodeGroup>
```javascript JavaScript
function updateUI(intent) {
  const statusMessages = {
    pending: 'Queued for processing...',
    planning: 'Analyzing and planning execution...',
    executing: 'Executing transactions on blockchain...',
    completed: 'Successfully completed!',
    failed: 'Execution failed'
  };
  
  const message = statusMessages[intent.status] || 'Unknown status';
  
  // Update status message
  document.getElementById('status').textContent = message;
  
  // Show execution plan if available
  if (intent.executionPlan) {
    displayExecutionPlan(intent.executionPlan);
  }
  
  // Show progress based on execution plan steps
  if (intent.executionPlan?.steps) {
    const progress = calculateProgress(intent);
    updateProgressBar(progress);
  }
}
```
</CodeGroup>

## Displaying execution plans

Show users what Pan is doing:

<CodeGroup>
```javascript JavaScript
function displayExecutionPlan(plan) {
  const steps = plan.steps || [];
  const container = document.getElementById('execution-steps');
  
  container.innerHTML = steps.map((step, index) => {
    const stepDescriptions = {
      swap: `Swap ${step.amount} ${step.from} → ${step.to}`,
      bridge: `Bridge ${step.amount} ${step.asset} from ${step.from} → ${step.to}`,
      consolidate: `Consolidate ${step.amount} ${step.asset}`,
      deposit: `Deposit ${step.amount} ${step.asset} into ${step.protocol}`
    };
    
    return `
      <div class="execution-step">
        <span class="step-number">${index + 1}</span>
        <span class="step-description">${stepDescriptions[step.type]}</span>
      </div>
    `;
  }).join('');
  
  // Show cost estimates
  if (plan.estimatedCostUsd) {
    document.getElementById('estimated-cost').textContent = 
      `Estimated cost: $${plan.estimatedCostUsd}`;
  }
}
```
</CodeGroup>

## Error handling

Handle errors gracefully during polling:

<AccordionGroup>
  <Accordion title="Network errors">
    If a poll fails due to network issues, wait longer before retrying (e.g., double the interval) to avoid overwhelming the API.
  </Accordion>
  
  <Accordion title="Failed intents">
    When an intent fails, display the error message from `intent.error.message` and provide options to retry if appropriate.
  </Accordion>
  
  <Accordion title="Timeouts">
    If an intent takes too long, inform the user and provide contact information for support. Consider implementing a "stuck intent" detection mechanism.
  </Accordion>
</AccordionGroup>

## Optimizing polling

<CardGroup cols={2}>
  <Card title="Backoff strategy" icon="chart-line-down">
    Start with shorter intervals (2-3 seconds) and increase to 5-10 seconds as the intent progresses.
  </Card>
  <Card title="Stop on completion" icon="stop">
    Always stop polling immediately when status becomes `completed` or `failed` to avoid unnecessary requests.
  </Card>
  <Card title="Rate limit awareness" icon="clock">
    Be mindful of rate limits. If polling many intents, stagger requests or use longer intervals.
  </Card>
  <Card title="Client-side state" icon="database">
    Cache intent state locally to reduce API calls. Only poll when necessary.
  </Card>
</CardGroup>

## Webhooks (coming soon)

In the future, Pan will support webhooks for real-time notifications, eliminating the need for polling. Until then, polling is the recommended approach.

<Note>
  **Webhook support**: We're working on webhook support for instant notifications. Sign up for updates to be notified when it's available.
</Note>

## Best practices summary

<Tip>
  ✅ Use 5-second polling intervals for active operations
  ✅ Stop polling when status is `completed` or `failed`
  ✅ Show execution plans to users for transparency
  ✅ Handle network errors with exponential backoff
  ✅ Display progress and estimated costs
  ✅ Provide clear error messages when intents fail
</Tip>

<Warning>
  ❌ Don't poll more frequently than every 2 seconds
  ❌ Don't continue polling after completion
  ❌ Don't ignore errors during polling
  ❌ Don't block UI while polling
</Warning>

## Related guides

<CardGroup cols={2}>
  <Card
    title="Executing intents"
    icon="target"
    href="/guides/executing-intents"
  >
    Learn how to create intents
  </Card>
  <Card
    title="Intents concept"
    icon="book"
    href="/guides/concepts/intents"
  >
    Understand intent lifecycle
  </Card>
</CardGroup>

